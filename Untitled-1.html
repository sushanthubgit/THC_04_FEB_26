<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture-Controlled 3D Particle System</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Hidden video element for MediaPipe */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px; /* Hide but keep active */
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .loader {
            border: 4px solid #333;
            border-top: 4px solid #0ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none; /* Let clicks pass through to canvas if needed, but buttons need pointer-events auto */
        }

        h1 {
            font-size: 1.5rem;
            margin: 0 0 5px 0;
            text-shadow: 0 0 10px #0ff;
            letter-spacing: 2px;
        }

        p {
            font-size: 0.9rem;
            color: #aaa;
            margin: 0 0 20px 0;
            max-width: 300px;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-bottom: 20px;
            color: #0ff;
        }

        /* Controls */
        #controls {
            pointer-events: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 400px;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        button.active {
            background: #0ff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Hand Debug Preview (Optional, bottom right) */
        #cam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid #333;
            z-index: 10;
            transform: scaleX(-1); /* Mirror */
            opacity: 0.7;
        }

    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">Initializing Neural Network...</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <h1>ETHERIC FLUX</h1>
        <p>Use your hand to rotate. Pinch to expand.</p>
        <div class="status-badge" id="hand-status">Waiting for hand...</div>
        
        <div id="controls">
            <button onclick="setShape('sphere')" class="active" id="btn-sphere">Sphere</button>
            <button onclick="setShape('heart')" id="btn-heart">Heart</button>
            <button onclick="setShape('saturn')" id="btn-saturn">Saturn</button>
            <button onclick="setShape('dna')" id="btn-dna">Helix</button>
            <button onclick="setShape('flower')" id="btn-flower">Lotus</button>
        </div>
    </div>

    <!-- Hidden Video Source -->
    <video id="input-video"></video>
    
    <!-- Camera Preview Canvas (Debug) -->
    <canvas id="cam-preview"></canvas>

    <!-- 3D Scene Container -->
    <div id="canvas-container"></div>

    <script>
        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        const CAM_FOV = 75;
        
        // --- Global State ---
        let particles, geometry, material;
        let scene, camera, renderer;
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        let currentPositions = new Float32Array(PARTICLE_COUNT * 3);
        let baseColors = new Float32Array(PARTICLE_COUNT * 3); // Store current active shape base colors
        let targetColors = new Float32Array(PARTICLE_COUNT * 3); // Colors we are morphing towards
        let currentColors = new Float32Array(PARTICLE_COUNT * 3); // Actual colors rendered
        
        // Interaction State
        let handPresent = false;
        let handX = 0, handY = 0; // Normalized -1 to 1
        let pinchStrength = 0; // 0 to 1
        let sceneRotationTarget = { x: 0, y: 0 };
        let currentShape = 'sphere';

        // --- 1. Three.js Setup ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Create Particles
            geometry = new THREE.BufferGeometry();
            
            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colArray = new Float32Array(PARTICLE_COUNT * 3);

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                posArray[i3] = (Math.random() - 0.5) * 50;
                posArray[i3+1] = (Math.random() - 0.5) * 50;
                posArray[i3+2] = (Math.random() - 0.5) * 50;
                
                colArray[i3] = 0.0;
                colArray[i3+1] = 1.0;
                colArray[i3+2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: texture,
                transparent: true,
                opacity: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            currentPositions.set(posArray);
            targetColors.set(colArray);
            currentColors.set(colArray);

            generateSphere();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 2. Shape Generators ---
        
        function updateActiveButton(id) {
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${id}`).classList.add('active');
        }

        function setShape(type) {
            currentShape = type;
            updateActiveButton(type);

            const tPositions = targetPositions;
            const tColors = targetColors;
            
            let idx = 0;
            
            if (type === 'sphere') {
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const phi = Math.acos( -1 + ( 2 * i ) / PARTICLE_COUNT );
                    const theta = Math.sqrt( PARTICLE_COUNT * Math.PI ) * phi;
                    const r = 12;

                    tPositions[idx] = r * Math.cos(theta) * Math.sin(phi);
                    tPositions[idx+1] = r * Math.sin(theta) * Math.sin(phi);
                    tPositions[idx+2] = r * Math.cos(phi);

                    // Cyan Blue Theme
                    tColors[idx] = 0.0;
                    tColors[idx+1] = 0.7 + Math.random() * 0.3;
                    tColors[idx+2] = 1.0;
                    idx += 3;
                }
            }
            else if (type === 'heart') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    let t = Math.random() * Math.PI * 2;
                    const scale = 0.8;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const z = (Math.random() - 0.5) * 10 * (1 - Math.abs(y)/20);

                    tPositions[idx] = x * scale;
                    tPositions[idx+1] = y * scale;
                    tPositions[idx+2] = z * scale;

                    // Updated: Green Firework Style
                    tColors[idx] = 0.1;
                    tColors[idx+1] = 0.9 + Math.random() * 0.1;
                    tColors[idx+2] = 0.2 + Math.random() * 0.3;
                    idx += 3;
                }
            }
            else if (type === 'saturn') {
                const planetParticles = Math.floor(PARTICLE_COUNT * 0.4);
                
                // Planet Body
                for (let i = 0; i < planetParticles; i++) {
                    const phi = Math.acos( -1 + ( 2 * i ) / planetParticles );
                    const theta = Math.sqrt( planetParticles * Math.PI ) * phi;
                    const r = 8;
                    tPositions[idx] = r * Math.cos(theta) * Math.sin(phi);
                    tPositions[idx+1] = r * Math.sin(theta) * Math.sin(phi);
                    tPositions[idx+2] = r * Math.cos(phi);

                    // Updated: Dark / Deep Gold Planet
                    tColors[idx] = 0.4 + Math.random() * 0.2;
                    tColors[idx+1] = 0.3 + Math.random() * 0.1;
                    tColors[idx+2] = 0.05;
                    idx += 3;
                }

                // Rings
                const ringParticles = PARTICLE_COUNT - planetParticles;
                for (let i = 0; i < ringParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 12 + Math.random() * 10;
                    
                    tPositions[idx] = Math.cos(angle) * r;
                    tPositions[idx+1] = (Math.random() - 0.5) * 0.5;
                    tPositions[idx+2] = Math.sin(angle) * r;

                    // Updated: Bright Yellow Rings
                    tColors[idx] = 1.0;
                    tColors[idx+1] = 0.95;
                    tColors[idx+2] = 0.0;
                    idx += 3;
                }
            }
            else if (type === 'dna') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = (i / PARTICLE_COUNT) * Math.PI * 20;
                    const radius = 6;
                    const height = 30;
                    const strand = i % 2 === 0 ? 0 : Math.PI;
                    
                    const x = Math.cos(t + strand) * radius;
                    const y = (i / PARTICLE_COUNT - 0.5) * height;
                    const z = Math.sin(t + strand) * radius;

                    tPositions[idx] = x + (Math.random()-0.5);
                    tPositions[idx+1] = y * 1.5;
                    tPositions[idx+2] = z + (Math.random()-0.5);

                    // Purple/Magenta Theme
                    tColors[idx] = 0.6 + Math.random() * 0.4;
                    tColors[idx+1] = 0.1;
                    tColors[idx+2] = 1.0;
                    idx += 3;
                }
            }
            else if (type === 'flower') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const k = 4;
                    const rBase = Math.cos(k * theta); 
                    const layer = Math.random();
                    const r = 15 * rBase * layer + 2; 

                    tPositions[idx] = r * Math.cos(theta);
                    tPositions[idx+1] = r * Math.sin(theta);
                    tPositions[idx+2] = (Math.pow(layer, 2) * 10) - 5; 

                    // Updated: Yellow and Dark Green Contrast
                    if (Math.random() > 0.5) {
                        tColors[idx] = 1.0; // Yellow petals
                        tColors[idx+1] = 0.9;
                        tColors[idx+2] = 0.0;
                    } else {
                        tColors[idx] = 0.02; // Dark Green stems/base
                        tColors[idx+1] = 0.3;
                        tColors[idx+2] = 0.1;
                    }
                    idx += 3;
                }
            }
        }

        const generateSphere = () => setShape('sphere');

        // --- 3. Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            if (handPresent) {
                sceneRotationTarget.y = handX * 3; 
                sceneRotationTarget.x = handY * 3;
            } else {
                sceneRotationTarget.y += 0.002;
                sceneRotationTarget.x = sceneRotationTarget.x * 0.95;
            }

            particles.rotation.x += (sceneRotationTarget.x - particles.rotation.x) * 0.05;
            particles.rotation.y += (sceneRotationTarget.y - particles.rotation.y) * 0.05;

            const positions = particles.geometry.attributes.position.array;
            const colorsAttr = particles.geometry.attributes.color.array;

            const expansion = 1 + (pinchStrength * 4);
            const hueShift = handPresent ? (handX + 1) * 0.1 : 0;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const speed = 0.03 + (i % 100) * 0.0002; 
                
                let tx = targetPositions[i3];
                let ty = targetPositions[i3+1];
                let tz = targetPositions[i3+2];

                tx += Math.sin(time + ty * 0.1) * 0.2;
                ty += Math.cos(time + tx * 0.1) * 0.2;

                tx *= expansion;
                ty *= expansion;
                tz *= expansion;

                currentPositions[i3]   += (tx - currentPositions[i3]) * speed;
                currentPositions[i3+1] += (ty - currentPositions[i3+1]) * speed;
                currentPositions[i3+2] += (tz - currentPositions[i3+2]) * speed;

                positions[i3]   = currentPositions[i3];
                positions[i3+1] = currentPositions[i3+1];
                positions[i3+2] = currentPositions[i3+2];

                // Smoothly morph colors
                currentColors[i3]   += (targetColors[i3] - currentColors[i3]) * 0.05;
                currentColors[i3+1] += (targetColors[i3+1] - currentColors[i3+1]) * 0.05;
                currentColors[i3+2] += (targetColors[i3+2] - currentColors[i3+2]) * 0.05;

                if (pinchStrength > 0.5) {
                    // Overriding with fire when pinching
                    colorsAttr[i3]   = 1.0; 
                    colorsAttr[i3+1] = 0.8 * (1 - pinchStrength); 
                    colorsAttr[i3+2] = 0.0; 
                } else {
                    colorsAttr[i3] = Math.min(1, currentColors[i3] + hueShift);
                    colorsAttr[i3+1] = Math.max(0, currentColors[i3+1] - hueShift*0.5);
                    colorsAttr[i3+2] = Math.min(1, currentColors[i3+2] + hueShift);
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }


        // --- 4. MediaPipe Hands Setup ---
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('cam-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusElement = document.getElementById('hand-status');

        function onResults(results) {
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handPresent = true;
                statusElement.innerText = "Hand Detected";
                statusElement.style.borderColor = "#0f0";
                statusElement.style.color = "#0f0";

                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                drawLandmarks(previewCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const palmX = landmarks[9].x; 
                const palmY = landmarks[9].y;
                handX = (palmX - 0.5) * -2; 
                handY = (palmY - 0.5) * -2;

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const maxDist = 0.2;
                const clampedDist = Math.min(Math.max(distance, 0), maxDist);
                pinchStrength = 1 - (clampedDist / maxDist);
                if(pinchStrength < 0.2) pinchStrength = 0;

            } else {
                handPresent = false;
                statusElement.innerText = "Waiting for hand...";
                statusElement.style.borderColor = "#0ff";
                statusElement.style.color = "#0ff";
                pinchStrength = 0;
            }
            previewCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        initThree();
        
        cameraUtils.start()
            .then(() => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            })
            .catch(err => {
                console.error("Camera Error:", err);
                document.getElementById('loading-text').innerText = "Camera access denied or error. Check permissions.";
                document.getElementById('loading-text').style.color = "red";
            });

    </script>
</body>
</html>